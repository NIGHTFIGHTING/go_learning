1.thread和kernel entity是1:1，由系统直接调用。系统线程由cpu直接调度。调度效率搞，线程上下文切换存在内核对象切换   
多个线程都和系统对应，切换小很多
2.M:kenel entity系统线程
P:Processor go语言协程处理器
G:协程
3.processor在不同的系统线程里，每个processor挂着一个准备运行的协程队列
如果一个协程运行时间特别长，把某一个processor都站住了，其他在队列里面的协程
会等待很久？
在go启动时候，一个守护线程做计数，记录每一个processor完成协程的数量。
当一段时间某一个processor完成协程数量没有发生变化的时候，向协程任务栈插入特殊标记
当协程运行遇到非内连函数时候，读到这个标记，把自己中断下来，插入到队列队尾
4.
当某一个协程被系统中断，比如等待io，为了提高整体并发，processor把自己移动到另一个
可运行的系统线程中，继续执行协程队列中其他的协程。当被中断协程唤醒完成后，假如到某一个
协程等待队列，或者全局等待队列。
当协程被中断，在寄存器当运行状态被保存在协程对象里，当协程再次获得运行机会，再次写入寄存器

27.
当receiver不知道producer放多少数据，receiver如何知道数据放完？
1.特殊token可以告诉什么时候producer数据产生完成，比如-1代表数据放完了。 receiver收到
-1，退出，代表数据接受完成。 尤其在多个receiver情况，producer需要
知道现在有几个receiver，放入几个-1
两个矛盾
如果不放入token，receiver需要知道producer产生多少数据，什么时候数据产生 完
尤其在多个receiver情况,receiver在调度的情况下，receiver不清楚自己可以处理几个数据，
这个方案只能是在一个receiver情况下可行
即便放入一个标志,在多个receiver情况下，produce需要确切知道现在receiver个数，
因为每个receiver都需要收到一个结束标志 ，这样写程序耦合度很高
2.如果token方案可行，producer需要知道确切receiver个数,因为每个receiver都需要收到一个
结束标志。程序耦合度高

Golang从入门到精通:讲师:少林之巅
https://study.163.com/course/introduction.htm?courseId=1004720008&share=1&shareId=1396904690#/courseDetail?tab=1
https://www.bilibili.com/video/av83350913?p=3
慕课网:Go语言从入门到达人之路
https://coding.imooc.com/learningpath/route?pathId=5
天翼云盘链接:
https://cloud.189.cn/t/YBZF7bRNBVJj（访问码：0579）
