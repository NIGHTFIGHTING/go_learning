1.thread和kernel entity是1:1，由系统直接调用。系统线程由cpu直接调度。调度效率搞，线程上下文切换存在内核对象切换   
多个线程都和系统对应，切换小很多
2.M:kenel entity系统线程
P:Processor go语言协程处理器
G:协程
3.processor在不同的系统线程里，每个processor挂着一个准备运行的协程队列
如果一个协程运行时间特别长，把某一个processor都站住了，其他在队列里面的协程
会等待很久？
在go启动时候，一个守护线程做计数，记录每一个processor完成协程的数量。
当一段时间某一个processor完成协程数量没有发生变化的时候，向协程任务栈插入特殊标记
当协程运行遇到非内连函数时候，读到这个标记，把自己中断下来，插入到队列队尾
4.
当某一个协程被系统中断，比如等待io，为了提高整体并发，processor把自己移动到另一个
可运行的系统线程中，继续执行协程队列中其他的协程。当被中断协程唤醒完成后，假如到某一个
协程等待队列，或者全局等待队列。
当协程被中断，在寄存器当运行状态被保存在协程对象里，当协程再次获得运行机会，再次写入寄存器

